---
title: C/C++核心语法学习（一）
mathjax: false
tags:
- 指针
- C++
- C
categories:
- 学习记录
- C++
---

![COde](https://s2.loli.net/2023/05/03/aNE6XkqKnSY2oQM.jpg)

本篇主要是部分C/C++的指针学习。

<!-- more -->

## 指针

上面的图中灰，色的一长排就是计算机的存储空间。其中每一个小方格代表一字节，而我们定义的变量 `a` 到变量 `e` 就会存放在这些存储空间里面。由于变量的类型不同，所以它们所需要的存储空间也不同。这里，每一个变量存放的位置就称为它的**地址**（Address）。比如变量 `a` 存放在了内存空间 `0x62fe08` 的位置上，那么就说变量 `a` 的地址为 `0x62fe08`；其余同理。

### 取地址与解地址

| 运算符 |     名称     |            作用             |
| :----: | :----------: | :-------------------------: |
|   &a   | 取地址运算符 | 取得 `a` 在存储空间中的地址 |
|   *a   | 解地址运算符 |  取得地址 `a` 中存放的变量  |

和指针相关的操作就这两个核心的。取地址运算符用于获得一个地址，解地址运算符用于获取一个内存地址中存放的内容。我们这样使用：

```c++
#include <iostream>
using namespace std;
int main() {
    int c{76};
    int* address{&c};
    (*address) = 42;
    cout << c << endl;
}

// 输出为42
```

像 `int*` 这种声明，用于保存地址的变量称为**指针**（Pointer），而用于保存地址的类型称为**指针类型**（Pointer type）。这里把 `address` 声明并定义为 `c` 的地址。这时，我们首先把 `address` 解地址，然后给它赋值——就相当于给 `c` 赋值；最后输出 `c`，发现 `c` 的值确实改变了。这个例子表明，我们通过指针可以通过指针来改变一个变量的值。

### 指针的定义

指针的定义是这样的：

```
基类型* 指针名 初始化器;
int* address{&c};
```

当你声明并定义一个指针的时候，你需要提供一个称为 `基类型` 的东西，此时这个指针存储的地址**只能**是 `基类型` 这个类型变量的地址。比如：

```c++
int c{76};
int d{42};
int* address{&c}; // address 的基类型为 int*，所以它只存储 int 型变量的地址
address = &d;     // 将 int 型变量 d 的地址赋值给 address
short e{1};
address = &e;     // 错误：address 不能存储 short 型变量的地址
```

当一个指针的基类型为 `T` 时，称这个指针的类型为**指向 `T` 的指针**类型。类似地，如果一个指针存储了变量 `a` 的地址，则称这个指针**指向**变量 `a`。

### 指针初始化

指针也是变量，因此它的声明方式和普通变量一致：初始化器也是可选的。因此你完全可以

```c++
int* a;  // 指向 int 的指针类型
char* b; // 指向 char 的指针类型
```

这样不写初始化器。但是问题来了，如果不写初始化器，这样的表达式：

```c++
*a = 3;
*b = 'A';
```

会造成什么后果呢？答案是未知的。因为你根本不知道没有初始化时，`a` 这个指针里存放的到底是那个地址，`*a` 是个什么东西根本无法得知。如果 `a` 或者 `b` 指向了非法的存储空间，然后你又对这片存储空间进行了修改，可能会导致很严重的后果（甚至可能影响到操作系统）。所以我们认为**不初始化指针是非常危险的**。为了解决这个问题，C++ 提供了一个称为**空指针**（Null pointer）的字面量：`nullptr`。它可以转换为指向任何类型的指针类型：

```c++
int* a{nullptr};
char* b{nullptr};
```

尽管此时访问 `*a` 和 `*b` 仍然是非法的（会导致运行时错误），但是它不会造成任何危险。所以，我在这里建议：定义指针时必须初始化，若无合适的初始化值则初始化为 `nullptr`。

### 指针的简单使用

下面给出了一个使用指针交互两个变量值的实现：

```c++
#include <iostream>
using namespace std;
int main() {
    int a, b;
    cin >> a >> b;
    int* pa{&a};
    int* pb{&b};

    // exchange
    int temp{*pa};
    *pa = *pb;
    *pb = temp;

    cout << a << " " << b << endl;
}
```

你可能会觉得指针操作很多余，因为我完全可以新建一个变量存储作为temp存储要交换的值的之一，然后使用类似的赋值语句完成交换。那么我们看一下使用指针的优势在哪，看看下面的代码：

```c++
#include <iostream>
using namespace std;
void exchange(int* pa,int* pb) {
    int temp{*pa};
    *pa = *pb;
    *pb = temp;
}
int main() {
    int a, b;
    cin >> a >> b;
    exchange(&a, &b);
    cout << a << " " << b << endl;
}
```

我们可以把交换部分的代码用 `exchange` 函数给它包起来。这里，如果用变量作为形参，那么 `exchange` 函数并不会如期工作（因为实参初始化形参时发生了拷贝）。但是如果用指针作为形参，则一切就能正常运转：因为，`exchange` 函数得到的是地址——就是 `main` 函数里变量存放的位置。当你把这个位置交给 `exchange` 函数时，它便可以随意地通过这个地址去访问 `main` 中的变量。就好像你把你家门牌号告诉了其它人，那么这些人就可以随时随地通过门牌号找到你家。

### 指针运算

我们看一下指针的运算：

```c++
#include <iostream>
using namespace std;
int main() {
    long* a{nullptr};
    short* b{nullptr};
    cout << a << " " << b << endl;
    cout << a + 1 << " " << b + 1 << endl;
}

//0 0
//0x4 0x2
```

对于指向 `T` 类型的指针，它 `+1` 的含义则是，让这个指针**向后移动 `sizeof(T)` 个字节**。比如刚才的例子中，`sizeof(b)` 为 `2`，所以 `b + 1` 使得原来为 `0` 的指针向后移动到 `0x2`；同理，`sizeof(a)` 若为 `4`，则 `a + 1` 向后移动到 `0x4`。（若 `sizeof(long)` 为 `8`，则移动到 `0x8`。）

类似地，若又一个指向 `T` 类型的指针 `p`，则 `p + n` 就是让这个指针向后移动 `sizeof(T) * n` 个字节。反之，`p - n` 就是让这个指针向前移动 `sizeof(T) * n` 个字节。

除此之外，两个指针之间可以做减法（如 `p1 - p2`），这样运算得到的结果是两个地址之间相差了多少个 `sizeof(T)`。

![pointer +1](https://s2.loli.net/2023/05/03/3CRzir4mDfyqa1V.png)

## 数组与指针

### 指向元素的指针

```c++
int a[5]{};
int* p{&a[0]};
```

这里，用 `a[0]` 的地址初始化了指针 `p`，从而让 `p` 称为一个指向数组 `a` 首个元素的指针。然后，我们尝试：

```c++
int* q{p + 1};
```

 `q` 此时会指向 `a[1]`。当 `p + 1` 时，会自动向后移动一个 `sizeof(int)` 那么多：因为 `p` 拥有指向 `int` 的指针类型。同时，由于数组的元素是紧密、连续地存储的，所以当指向 `a[0]` 的指针向后移动一个 `sizeof(int)` 时，它恰好就指向了 `a[1]`。这就是指针加减法的用途了，基于此你也可以这样遍历：

```c++
int* p{&a[0]};
for (int i{0}; i < 5; i++) {
    cout << *(p + i) << endl;
}
```

### 数组到指针的转换

这是最难的一部分了。我们刚开始的指针初始化是这样写的：`int* p{&a[0]};`。但是这样写起来也太难受了，我们其实可以这样写：

```c++
int* p{a};
```

**数组可以隐式转换到指向其首元素的指针**。也就是，数组 `a` 可以转换为 `&a[0]`。在各种期望指针的语境下，如果你放一个数组进去，那么 C++ 就会自动执行这个隐式转换。我们看个例子：

```c++
int a[5]{};
cout << a << endl;
//0x62fe00
```

我们知道cout是不能输出数组的，但数组可以隐式的转换成指针，所以输出是一个指针的地址。因此如果你要遍历数组的内容时，可以这么写：

```c++
#include <iostream>
using namespace std;
int main() {
    int a[5]{1, 2, 3, 4, 5};
    for (int i{0}; i < 5; i++) {
        cout << *(a + i) << endl;
    }
}
```

这是因为，数组不能做加法，但指针却能。所以这时发生数组到指针的转换，`a + i` 理解为 `&a[0] + i`。接下来的过程就和上文中的内容一样了，这里不再赘述。

### 函数的调用呢？

我们知道，c++中**函数的参数不能是数组，但是可以是一个指针！**所以在把数组作为参数时，

```c++
#include <iostream>
using namespace std;
void f(int x[5]) {
    // 此时 x 实际上是一个指针，下面输出的是 sizeof(int*)
    cout << sizeof(x) << endl;
}
int main() {
    int a[5];
    f(a);
}
```

会发生从数组到指针的转换。而且这个时候，别看形参长成一个数组的样子，但它仍然是一个指针。这个被称为形参数组到指针的退化（Decay）。换而言之，`void f(int x[5]);` 和 `void f(int* x);` 是完全等价的写法。

此外，默认的下标表达式 `a[b]` 总是会解析为 `*(a + b)` 来运算。因此如果你想获取数组的第四个元素，不仅可以写 `a[3]`，你甚至可以写 `3[a]`：因为它只会转换成 `*(3 + a)`，这和 `*(a + 3)` 是完全等价的。类似地，如果你想访问指针 `x` 指向元素往后第 `i` 个元素，除了 `*(x + i)` 这种写法，也可以直接用 `x[i]`。

### 数组的地址

最后来考虑这样一个事情。如果有 `int a[5]{};`，那么 `&a` 是什么意思呢？字面上，`&a` 就是取数组 `a` 的地址。没错，就是这样。那么请看下面的代码：

```c++
#include <iostream>
using namespace std;
int main() {
    int a[5]{};
    cout << &a << endl;
    cout << a << endl;
}
//0x62fe00
//0x62fe00
```

这时，`&a` 和 `a` 有什么区别呢？首先，`a` 会转换为 `&a[0]` 这个地址，此时你要注意到它是数组首元素的首字节地址——而 `&a` 是整个数组首字节的地址——所以它们两个地址的值是相同的。不同点在于，这两个地址的基类型不一样。`a` 被转换为指向 `int` 的指针类型；而 `&a` 则是指向 `int[5]` 的指针类型。所以有了下面的结果：

```c++
#include <iostream>
using namespace std;
int main() {
    int a[5]{};
    cout << sizeof(*(&a)) << endl;
    cout << sizeof(*( a)) << endl;
}
//20
//4
```

说白了，对`a`取值的时候只关注第一个元素，但对`&a`取值时取得是整个数组。

## 指向函数的指针

之前讨论的一直是指向变量的指针。实际上，C/C++ 还提供了指向函数的指针，俗称为**函数指针**。它的声明如下：

```c++
返回值类型 (*指针名)(参数列表)初始化器;
int (*ptr)(int, int){nullptr};
```

它是一个基类型为函数的指针。其中这个函数必须接收 `参数列表` 所规定的数量、类型的参数，且返回值类型为 `返回值类型`。比如上面示例中的函数指针 `ptr`，它可以：

```c++
int (*ptr)(int, int){nullptr};
int max(int, int);
int main() {
    ptr = &max; // ptr 存储了函数 max 的地址，即指向 max
}
```

你可以通过函数指针的解地址运算符来调用其所指向的函数：

```c++
int (*ptr)(int, int){&max};
(*ptr)(3, 5); // 调用了 max 函数
```

除此之外，C/C++ 提供了一些“快捷方式”：

1. 所有的函数都可以隐式转换到指向自身的指针；
2. 函数指针可以不经过解地址运算符，直接调用其所指向的函数。

举个例子：

```c++
int (*ptr)(int, int){nullptr};
int max(int a, int b) {
    return a > b ? a : b;
}
int main() {
    ptr = &max;   // 正常的赋值
    ptr = max;    // 亦可：max 先隐式转换为 &max，随后赋值

    (*ptr)(3, 5); // 先解地址，然后调用
    ptr(3, 5);    // 亦可：允许不解地址，直接调用其所指向的函数
}
```

## 总结

本篇主要介绍了指针的概念、如何定义一个指针、指针与数组的关系以及指针和函数的关系。需要注意一点，C和C++的指针区别在于C没有`nullptr`。非常感谢[谷雨同学的 C++ 教程 (learn-cpp.tk)](https://learn-cpp.tk/ch04/pointer/pointer_def_2.html)提供的教学材料，受益匪浅！
